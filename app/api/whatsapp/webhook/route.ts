import { NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { whatsappService } from '@/lib/whatsapp-service';
import { AppointmentStatus } from '@prisma/client';

interface WhatsAppWebhookData {
  event: string;
  instance: string;
  data: {
    key: {
      remoteJid: string;
      fromMe: boolean;
      id: string;
    };
    message?: {
      buttonsResponseMessage?: {
        selectedButtonId: string;
        selectedDisplayText: string;
      };
      conversation?: string;
      extendedTextMessage?: {
        text: string;
      };
    };
    pushName: string;
    messageTimestamp: number;
    selectedButtonId?: string; // Para bot√µes diretos
  };
}

// Adicionar log mais detalhado no in√≠cio do webhook
export async function POST(request: Request) {
  try {
    const body = await request.text();
    
    // Log de entrada com timestamp
    console.log('\n=== WEBHOOK RECEBIDO ===');
    console.log('üïê Timestamp:', new Date().toISOString());
    console.log('üì¶ Body bruto:', body);
    console.log('üìè Tamanho do body:', body.length);
    
    if (!body || body.trim() === '') {
      console.log('‚ùå BODY VAZIO - Ignorando webhook');
      return NextResponse.json({ success: true, message: 'Body vazio ignorado' });
    }
    
    let data: WhatsAppWebhookData;
    try {
      data = JSON.parse(body);
    } catch (parseError) {
      console.log('‚ùå ERRO AO PARSEAR JSON:', parseError);
      return NextResponse.json({ error: 'JSON inv√°lido' }, { status: 400 });
    }
    
    console.log('üìã Data parseado:', JSON.stringify(data, null, 2));
    console.log('üîç Event type:', data.event);
    console.log('üîç Instance:', data.instance);
    
    // Verificar se √© uma mensagem v√°lida
    if (!data.data) {
      console.log('‚ùå SEM DATA - Ignorando webhook');
      return NextResponse.json({ success: true, message: 'Sem data' });
    }
    
    // Log detalhado da estrutura da mensagem
    console.log('\n=== AN√ÅLISE DA MENSAGEM ===');
    console.log('üîç Tem key?:', !!data.data.key);
    console.log('üîç RemoteJid:', data.data.key?.remoteJid);
    console.log('üîç FromMe:', data.data.key?.fromMe);
    console.log('üîç Tem message?:', !!data.data.message);
    console.log('üîç Tem selectedButtonId direto?:', !!data.data.selectedButtonId);
    
    if (data.data.message) {
      console.log('üîç Tem buttonsResponseMessage?:', !!data.data.message.buttonsResponseMessage);
      console.log('üîç Tem conversation?:', !!data.data.message.conversation);
      console.log('üîç Tem extendedTextMessage?:', !!data.data.message.extendedTextMessage);
      
      if (data.data.message.conversation) {
        console.log('üí¨ Conversation:', data.data.message.conversation);
      }
      
      if (data.data.message.extendedTextMessage) {
        console.log('üí¨ ExtendedText:', data.data.message.extendedTextMessage.text);
      }
      
      if (data.data.message.buttonsResponseMessage) {
        console.log('üîò ButtonResponse:', data.data.message.buttonsResponseMessage);
      }
    }
    
    // Verificar se a mensagem √© do bot (fromMe: true) - IGNORAR SEMPRE
    if (data.data.key?.fromMe) {
      console.log('ü§ñ MENSAGEM DO BOT - Ignorando para evitar loop');
      return NextResponse.json({ success: true, message: 'Mensagem do bot ignorada' });
    }
    
    // Processar resposta de bot√£o (formato direto)
    if (data.data?.selectedButtonId) {
      const buttonId = data.data.selectedButtonId;
      const phone = data.data.key?.remoteJid?.replace('@s.whatsapp.net', '');
      
      console.log('\n=== PROCESSANDO BOT√ÉO DIRETO ===');
      console.log('üîò ButtonId:', buttonId);
      console.log('üì± Phone:', phone);
      
      return await processButtonResponse(buttonId, phone);
    }
    
    // Processar resposta de bot√£o (formato aninhado)
    if (data.data?.message?.buttonsResponseMessage?.selectedButtonId) {
      const buttonId = data.data.message.buttonsResponseMessage.selectedButtonId;
      const phone = data.data.key?.remoteJid?.replace('@s.whatsapp.net', '');
      
      console.log('\n=== PROCESSANDO BOT√ÉO ANINHADO ===');
      console.log('üîò ButtonId:', buttonId);
      console.log('üì± Phone:', phone);
      
      return await processButtonResponse(buttonId, phone);
    }
    
    // Processar resposta de texto
    if (data.data?.message?.conversation || data.data?.message?.extendedTextMessage?.text) {
      const messageText = (data.data.message?.conversation || data.data.message?.extendedTextMessage?.text || '');
      const phone = data.data.key?.remoteJid?.replace('@s.whatsapp.net', '');
      
      console.log('\n=== PROCESSANDO TEXTO ===');
      console.log('üí¨ Texto original:', messageText);
      console.log('üí¨ Texto upper:', messageText.toUpperCase());
      console.log('üì± Phone:', phone);
      console.log('üîç Cont√©m CONFIRMAR?:', messageText.toUpperCase().includes('CONFIRMAR'));
      console.log('üîç Cont√©m CANCELAR?:', messageText.toUpperCase().includes('CANCELAR'));
      
      // Verificar se √© uma mensagem v√°lida do usu√°rio
      if (!messageText || messageText.trim() === '') {
        console.log('‚ùå TEXTO VAZIO - Ignorando');
        return NextResponse.json({ success: true, message: 'Texto vazio ignorado' });
      }
      
      // Verificar se √© uma mensagem de sistema ou autom√°tica
      const systemMessages = [
        'mensagem apagada',
        'message deleted',
        'esta mensagem foi apagada',
        'this message was deleted'
      ];
      
      const isSystemMessage = systemMessages.some(msg => 
        messageText.toLowerCase().includes(msg.toLowerCase())
      );
      
      if (isSystemMessage) {
        console.log('ü§ñ MENSAGEM DE SISTEMA - Ignorando');
        return NextResponse.json({ success: true, message: 'Mensagem de sistema ignorada' });
      }
      
      if (messageText.toUpperCase().includes('CONFIRMAR')) {
        console.log('‚úÖ CONFIRMA√á√ÉO DETECTADA - Processando');
        console.log('üîÑ Chamando processTextResponse com CONFIRMAR...');
        const result = await processTextResponse('CONFIRMAR', phone);
        console.log('üì§ Resultado de processTextResponse:', result);
        return result;
      } else if (messageText.toUpperCase().includes('CANCELAR')) {
        console.log('‚ùå CANCELAMENTO DETECTADO - Processando');
        console.log('üîÑ Chamando processTextResponse com CANCELAR...');
        const result = await processTextResponse('CANCELAR', phone);
        console.log('üì§ Resultado de processTextResponse:', result);
        return result;
      } else {
        console.log('‚ÑπÔ∏è TEXTO N√ÉO RECONHECIDO - Ignorando');
        console.log('üìù Texto recebido:', messageText);
        console.log('üìù Texto em mai√∫sculas:', messageText.toUpperCase());
      }
    }
    
    console.log('\n=== WEBHOOK FINALIZADO SEM A√á√ÉO ===');
    return NextResponse.json({ success: true, message: 'Webhook processado sem a√ß√£o' });
    
  } catch (error) {
    console.error('\n=== ERRO NO WEBHOOK ===');
    console.error('‚ùå Erro:', error);
    console.error('üìä Stack:', error instanceof Error ? error.stack : 'Stack n√£o dispon√≠vel');
    return NextResponse.json({ error: 'Erro interno' }, { status: 500 });
  }
}

async function processButtonResponse(buttonId: string, phone: string) {
  try {
    console.log('üîò Processando resposta de bot√£o:', { buttonId, phone });
    
    if (!buttonId || !phone) {
      console.error('‚ùå ButtonId ou phone n√£o fornecidos');
      return NextResponse.json({ success: false, error: 'Dados incompletos' });
    }

    // Extrair a√ß√£o e ID do agendamento do buttonId
    // Formato esperado: "confirm_appointmentId" ou "cancel_appointmentId"
    const [action, appointmentId] = buttonId.split('_');
    
    console.log('üìã Dados extra√≠dos:', { action, appointmentId });
    
    if (!action || !appointmentId) {
      console.error('‚ùå Formato de buttonId inv√°lido:', buttonId);
      return NextResponse.json({ success: false, error: 'Formato de bot√£o inv√°lido' });
    }

    // Buscar o agendamento
    console.log('üîç Buscando agendamento:', appointmentId);
    const appointment = await prisma.appointment.findUnique({
      where: { id: appointmentId },
      include: {
        patient: true,
        profissional: true,
        clinic: true
      }
    });

    if (!appointment) {
      console.error('‚ùå Agendamento n√£o encontrado:', appointmentId);
      return NextResponse.json({ success: false, error: 'Agendamento n√£o encontrado' });
    }

    console.log('üì± Agendamento encontrado:', {
      id: appointment.id,
      patientName: appointment.patient.name,
      patientPhone: appointment.patient.phone,
      currentStatus: appointment.status
    });

    // Verificar se o telefone corresponde ao paciente
    const patientPhone = appointment.patient.phone?.replace(/\D/g, '') || '';
    const webhookPhone = phone.replace(/\D/g, '');
    
    // Normalizar telefones para compara√ß√£o (remover c√≥digo do pa√≠s se presente)
    const normalizePhone = (phoneNumber: string) => {
      // Remove todos os caracteres n√£o num√©ricos
      const cleanPhone = phoneNumber.replace(/\D/g, '');
      
      // Se o telefone tem 13 d√≠gitos e come√ßa com 55 (Brasil), remove o c√≥digo do pa√≠s
      if (cleanPhone.length === 13 && cleanPhone.startsWith('55')) {
        return cleanPhone.substring(2);
      }
      
      // Se o telefone tem 12 d√≠gitos e come√ßa com 55 (Brasil), remove o c√≥digo do pa√≠s
      if (cleanPhone.length === 12 && cleanPhone.startsWith('55')) {
        return cleanPhone.substring(2);
      }
      
      return cleanPhone;
    };
    
    const normalizedPatientPhone = normalizePhone(patientPhone);
    const normalizedWebhookPhone = normalizePhone(webhookPhone);
    
    console.log('üìû Comparando telefones:', {
      patientPhone,
      webhookPhone,
      normalizedPatientPhone,
      normalizedWebhookPhone,
      match: normalizedPatientPhone === normalizedWebhookPhone
    });
    
    if (normalizedPatientPhone !== normalizedWebhookPhone) {
      console.error('‚ùå Telefone n√£o corresponde ao paciente:', {
        expected: normalizedPatientPhone,
        received: normalizedWebhookPhone
      });
      return NextResponse.json({ success: false, error: 'Telefone n√£o autorizado' });
    }

    // Atualizar status do agendamento
    const newStatus = action === 'confirm' ? AppointmentStatus.CONFIRMADO : AppointmentStatus.CANCELADO;
    
    console.log('üîÑ Atualizando status:', {
      appointmentId,
      oldStatus: appointment.status,
      newStatus
    });
    
    const updatedAppointment = await prisma.appointment.update({
      where: { id: appointmentId },
      data: { status: newStatus }
    });
    
    console.log('‚úÖ Status atualizado com sucesso:', {
      appointmentId,
      newStatus: updatedAppointment.status
    });

    // Enviar mensagem de confirma√ß√£o
    const confirmationMessage = action === 'confirm' 
      ? `‚úÖ *Consulta Confirmada!*\n\nSua consulta foi confirmada com sucesso.\n\nNos vemos em breve! üòä`
      : `‚ùå *Consulta Cancelada*\n\nSua consulta foi cancelada.\n\nPara reagendar, entre em contato conosco.`;
      
    await whatsappService.sendAppointmentNotification({
      patientPhone: phone,
      patientName: appointment.patient.name,
      doctorName: '',
      date: '',
      time: '',
      clinicName: confirmationMessage
    });

    return NextResponse.json({ 
      success: true, 
      message: `Agendamento ${action === 'confirm' ? 'confirmado' : 'cancelado'} com sucesso`,
      appointmentId,
      newStatus
    });
    
  } catch (error) {
    console.error('üí• Erro ao processar resposta de bot√£o:', error);
    return NextResponse.json({ success: false, error: 'Erro interno' }, { status: 500 });
  }
}

// Remover completamente a fun√ß√£o processButtonResponse

async function processTextResponse(action: string, phone: string) {
  try {
    console.log('\n=== PROCESSANDO RESPOSTA DE TEXTO ===');
    console.log('üîÑ Action:', action);
    console.log('üì± Phone:', phone);
    console.log('üïê Timestamp:', new Date().toISOString());
    
    if (!action || !phone) {
      console.error('‚ùå Action ou phone n√£o fornecidos');
      return NextResponse.json({ success: false, error: 'Dados incompletos' });
    }

    // Normalizar telefone
    const normalizePhone = (phoneNumber: string) => {
      const cleanPhone = phoneNumber.replace(/\D/g, '');
      if (cleanPhone.length === 13 && cleanPhone.startsWith('55')) {
        return cleanPhone.substring(2);
      }
      if (cleanPhone.length === 12 && cleanPhone.startsWith('55')) {
        return cleanPhone.substring(2);
      }
      return cleanPhone;
    };
    
    const normalizedPhone = normalizePhone(phone);
    console.log('üìû Telefone normalizado:', normalizedPhone);
    
    // Buscar agendamento pelo telefone
    console.log('üîç Buscando agendamento...');
    const appointment = await prisma.appointment.findFirst({
      where: {
        patient: {
          phone: {
            contains: normalizedPhone
          }
        },
        status: {
          in: [AppointmentStatus.AGENDADO] // Removendo PENDENTE que n√£o existe
        }
      },
      include: {
        patient: true,
        profissional: true,
        clinic: true
      },
      orderBy: {
        date: 'asc'
      }
    });

    if (!appointment) {
      console.error('‚ùå Agendamento n√£o encontrado para telefone:', normalizedPhone);
      
      // Log de todos os agendamentos para debug
      const allAppointments = await prisma.appointment.findMany({
        where: { status: AppointmentStatus.AGENDADO },
        include: { patient: true }
      });
      
      console.log('üìã Agendamentos dispon√≠veis:');
      allAppointments.forEach(apt => {
        console.log(`  - ID: ${apt.id}, Paciente: ${apt.patient.name}, Telefone: ${apt.patient.phone}`);
      });
      
      return NextResponse.json({ success: false, error: 'Agendamento n√£o encontrado' });
    }

    console.log('üìã Agendamento encontrado:', {
      id: appointment.id,
      patientName: appointment.patient.name,
      patientPhone: appointment.patient.phone,
      currentStatus: appointment.status,
      date: appointment.date
    });

    // Verificar se o telefone corresponde
    const patientPhone = appointment.patient.phone?.replace(/\D/g, '') || '';
    const normalizedPatientPhone = normalizePhone(patientPhone);
    
    console.log('üìû Comparando telefones:', {
      webhookPhone: normalizedPhone,
      patientPhone: normalizedPatientPhone,
      match: normalizedPatientPhone === normalizedPhone
    });
    
    if (normalizedPatientPhone !== normalizedPhone) {
      console.error('‚ùå Telefone n√£o corresponde ao paciente');
      return NextResponse.json({ success: false, error: 'Telefone n√£o autorizado' });
    }

    // Atualizar status
    const newStatus = action === 'CONFIRMAR' ? AppointmentStatus.CONFIRMADO : AppointmentStatus.CANCELADO;
    
    console.log('üîÑ Atualizando status:', {
      appointmentId: appointment.id,
      oldStatus: appointment.status,
      newStatus,
      action
    });
    
    const updatedAppointment = await prisma.appointment.update({
      where: { id: appointment.id },
      data: { status: newStatus }
    });
    
    console.log('‚úÖ Status atualizado com sucesso:', {
      appointmentId: appointment.id,
      newStatus: updatedAppointment.status
    });

    
      
    console.log('üì§ Enviando mensagem de confirma√ß√£o...');
    
    // Definir a mensagem de confirma√ß√£o baseada no status
    const confirmationMessage = newStatus === AppointmentStatus.CONFIRMADO 
      ? `‚úÖ Agendamento confirmado com sucesso!\n\nüìÖ Data: ${appointment.date.toLocaleDateString('pt-BR')}\nüïê Hor√°rio: ${appointment.date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\nüë®‚Äç‚öïÔ∏è Profissional: ${appointment.profissional.name}\n\nObrigado por confirmar!`
      : `‚ùå Agendamento cancelado.\n\nüìÖ Data: ${appointment.date.toLocaleDateString('pt-BR')}\nüïê Hor√°rio: ${appointment.date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })}\n\nSe precisar reagendar, entre em contato conosco.`;

    // Enviar mensagem de confirma√ß√£o
    const messageResult = await whatsappService.sendSimpleMessage(
      `${phone}@s.whatsapp.net`, 
      confirmationMessage
    );
    
    console.log('üì± Resultado do envio:', messageResult);
    
    if (!messageResult.success) {
      console.error('‚ùå Falha ao enviar mensagem:', messageResult.error);
    }

    return NextResponse.json({ success: true, status: newStatus });
  } catch (error) {
    console.error('\n=== ERRO EM processTextResponse ===');
    console.error('‚ùå Erro:', error);
    console.error('üìä Stack:', error instanceof Error ? error.stack : 'Stack n√£o dispon√≠vel');
    return NextResponse.json({ error: 'Erro interno' }, { status: 500 });
  }
}

// M√©todo GET para verifica√ß√£o do webhook
export async function GET() {
  return NextResponse.json({ 
    status: 'Webhook ativo',
    description: 'Processa confirma√ß√µes de agendamento via WhatsApp'
  });
}